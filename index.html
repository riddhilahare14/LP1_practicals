<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Pass One Algorithm ‚Äî Flowchart (HTML/CSS)</title>
  <style>
    :root{
      --bg: #f8fafc;
      --card: #ffffff;
      --accent1: #5b21b6; /* indigo */
      --accent2: #0ea5a4; /* teal */
      --muted: #6b7280;
      --glass: rgba(255,255,255,0.7);
      --success: #16a34a;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background: linear-gradient(180deg,#eef2ff 0%, #f0f9ff 100%);
      color:#0f172a;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      padding:28px;
    }

    .container{max-width:1100px;margin:0 auto;}

    .header{text-align:center;margin-bottom:18px}
    .title{font-size:32px;font-weight:700;color:#0f172a;margin:0}
    .subtitle{color:var(--accent1);margin-top:6px;font-weight:600}
    .hint{color:var(--muted);font-size:13px;margin-top:8px}

    .notice{
      background:#fff7ed;border-left:6px solid #f59e0b;padding:12px;border-radius:8px;margin:20px 0;color:#92400e;
    }

    /* phase block */
    .phase{
      margin-bottom:22px;
      border-radius:10px;
      overflow:hidden;
      box-shadow:0 8px 24px rgba(2,6,23,0.06);
    }
    .phase-header{
      padding:14px 16px;
      display:flex;align-items:center;gap:12px;
      color:white;background:linear-gradient(90deg,#4338ca,#7c3aed);
    }
    .phase-header h2{margin:0;font-size:18px}
    .phase-body{background:var(--card);padding:18px;border-top:1px solid #eef2ff}

    .step{
      margin-bottom:14px;
    }
    .step-button{
      width:100%;
      display:flex;align-items:flex-start;gap:12px;
      background: #f8fafc;border:1px solid #e6edf6;padding:12px;border-radius:10px;
      cursor:pointer;transition:all .18s ease;
    }
    .step-button:hover{transform:translateY(-3px);box-shadow:0 6px 16px rgba(16,24,40,0.06)}
    .step-button.current{border-color:#4f46e5;background:#eef2ff;box-shadow:0 10px 30px rgba(79,70,229,0.08)}
    .step-button.completed{border-color:#bbf7d0;background:#f0fdf4}

    .icon{
      margin-top:4px;
      width:22px;height:22px;border-radius:999px;display:grid;place-items:center;background:#fff;border:1px solid #e6edf6;color:#9ca3af;
      font-weight:700;font-size:12px;
    }
    .icon.completed{background: #ecfdf5;color:var(--success);border-color: #bbf7d0}
    .step-content{flex:1}
    .step-title{font-size:15px;font-weight:700;margin:0 0 4px 0;color:#0f172a}
    .step-desc{margin:0;font-size:13px;color:var(--muted)}

    .chev{
      width:22px;height:22px;color:#9ca3af;transition:transform .18s ease;flex-shrink:0;
    }
    .chev.rotate{transform:rotate(90deg)}

    .details{
      margin-left:46px;margin-top:12px;padding:14px;border-radius:10px;background:#f8fbff;border:1px solid #e6f0ff;animation:fadeIn .12s ease;
    }
    .block{margin-bottom:12px}
    .block h4{margin:0 0 8px 0;font-size:14px;color:#0f172a}
    .list{padding-left:18px;margin:0;color:#0f172a}
    .list li{margin-bottom:6px;font-size:13px;color:#083344}
    pre.code{
      background:#0f172a;color:#b7f5d0;padding:12px;border-radius:8px;overflow:auto;font-family:ui-monospace,SFMono-Regular,Menlo,monospace;font-size:13px;
    }
    .example{background:#faf5ff;border:1px solid #f3e8ff;padding:10px;border-radius:8px;font-family:ui-monospace,SFMono-Regular,Menlo,monospace;font-size:13px;color:#221e3b}

    .connector{display:flex;justify-content:center;margin:14px 0}
    .connector .line{width:2px;height:44px;background:#c7d2fe;border-radius:2px}

    .howto{background:linear-gradient(90deg,#059669,#06b6d4);color:white;padding:16px;border-radius:10px;margin-top:18px}
    .howto p{margin:6px 0;font-size:14px}

    /* Java code panel */
    .code-panel{
      margin-top:18px;padding:12px;border-radius:8px;background:#111827;color:#f8fafc;border:1px solid rgba(255,255,255,0.04);
    }
    .code-header{display:flex;justify-content:space-between;align-items:center;gap:12px}
    .small-btn{background:rgba(255,255,255,0.06);border:none;color:white;padding:8px 10px;border-radius:8px;cursor:pointer}
    .copy-msg{font-size:13px;color:#bbf7d0;margin-left:8px}

    @keyframes fadeIn{from{opacity:0;transform:translateY(6px)} to{opacity:1;transform:none}}

    /* responsive */
    @media (max-width:720px){
      .phase-header h2{font-size:16px}
      .title{font-size:22px}
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1 class="title">Pass One Algorithm</h1>
      <div class="subtitle">Step-by-Step Flowchart</div>
      <div class="hint">Click a step to open details. Use the Java panel below to view your PassOne implementation.</div>
    </div>

    <div class="notice">
      <div style="font-weight:600">üìù For Exam/Viva:</div>
      <div style="font-size:13px;margin-top:6px;color:#7a4f1a">
        Follow the exact sequence when explaining. Each step is numbered and flows logically to the next.
      </div>
    </div>

    <!-- PHASES -->
    <div id="phases-root"></div>

    <div class="howto">
      <h3 style="margin:0 0 8px 0">üéì How to Use This for Viva/Exam</h3>
      <p><strong>1.</strong> Start with: "Pass One has several phases ‚Äî Initialization, Main loop, Directives, Machine instructions, Literal assignment, Completion."</p>
      <p><strong>2.</strong> Click through steps and read the detailed blocks.</p>
      <p><strong>3.</strong> Use the Java code below as the real implementation reference.</p>
    </div>

    <!-- Java Code Panel -->
    <div class="code-panel" aria-live="polite">
      <div class="code-header">
        <div style="display:flex;align-items:center;gap:12px">
          <strong>PassOne.java</strong>
          <span style="opacity:0.8;font-size:13px">(Your provided Java implementation)</span>
        </div>
        <div style="display:flex;align-items:center">
          <button id="copyBtn" class="small-btn">Copy code</button>
          <button id="toggleBtn" class="small-btn" style="margin-left:8px">Hide</button>
        </div>
      </div>

      <div id="javaBlock" style="margin-top:10px;max-height:420px;overflow:auto;">
        <pre id="javaCode" style="white-space:pre-wrap;font-family:ui-monospace,SFMono-Regular,Menlo,monospace;font-size:13px">
import java.io.*;
import java.util.*;

public class PassOne {

    // ---------- Tables ----------
    static Map<String, String[]> OPTAB = new HashMap<>();   // Operation Table
    static Map<String, Integer> REGTAB = new HashMap<>();   // Register Table
    static Map<String, Integer> CONDTAB = new HashMap<>();  // Condition Code Table
    static Map<String, Integer> SYMTAB = new LinkedHashMap<>(); // Symbol Table
    static List<Literal> LITTAB = new ArrayList<>();        // Literal Table
    static List<Integer> POOLTAB = new ArrayList<>();       // Pool Table
    static List<String> IC = new ArrayList<>();             // Intermediate Code List

    static int LC = 0;  // Location Counter

    // ---------- Literal Class ----------
    static class Literal {
        String value;
        int address;

        Literal(String value) {
            this.value = value;
            this.address = -1;  // -1 means address not assigned yet
        }
    }

    // ---------- Main ----------
    public static void main(String[] args) {
        initTables();

        try (BufferedReader br = new BufferedReader(new FileReader("program1.asm"))) {
            POOLTAB.add(0); // first literal pool starts from 0

            String line;
            while ((line = br.readLine()) != null) {
                line = line.trim();
                if (line.isEmpty()) continue;

                List<String> tokens = parseTokens(line);
                processLine(tokens);
            }

            printAndWriteOutputs();

        } catch (IOException e) {
            System.out.println("Error: " + e.getMessage());
        }
    }

    // ---------- Helper Functions ----------

    // Split line into tokens
    static List<String> parseTokens(String line) {
        String[] parts = line.split("\\\\s+|,");
        List<String> tokens = new ArrayList<>();
        for (String part : parts) if (!part.isEmpty()) tokens.add(part);
        return tokens;
    }

    // Process each line
    static void processLine(List<String> tokens) {
        String label = null, opcode, op1 = null, op2 = null;

        // Handle optional label
        if (OPTAB.containsKey(tokens.get(0)) || isDirective(tokens.get(0))) {
            opcode = tokens.get(0);
            if (tokens.size() > 1) op1 = tokens.get(1);
            if (tokens.size() > 2) op2 = tokens.get(2);
        } else {
            label = tokens.get(0);
            opcode = tokens.get(1);
            if (tokens.size() > 2) op1 = tokens.get(2);
            if (tokens.size() > 3) op2 = tokens.get(3);
        }

        // If label is present, add to symbol table
        if (label != null) SYMTAB.put(label, LC);

        // Handle directives and instructions
        switch (opcode) {
            case "START":
                LC = Integer.parseInt(op1);
                IC.add("(AD, 01) (C, " + op1 + ")");
                break;

            case "END":
            case "LTORG":
                handleLiteralPool();
                IC.add("(AD, " + (opcode.equals("END") ? "02" : "05") + ")");
                break;

            case "ORIGIN":
                int newLC = evaluateExpression(op1);
                IC.add("(AD, 03) (C, " + newLC + ")");
                LC = newLC;
                break;

            case "EQU":
                SYMTAB.put(label, evaluateExpression(op1));
                break;

            case "DS":
                IC.add("(DL, 02) (C, " + op1 + ")");
                LC += Integer.parseInt(op1);
                break;

            case "DC":
                IC.add("(DL, 01) (C, " + op1.replace("'", "") + ")");
                LC++;
                break;

            default:
                handleInstruction(opcode, op1, op2);
                LC++;
        }
    }

    // Handle Imperative Statements
    static void handleInstruction(String opcode, String op1, String op2) {
        String[] info = OPTAB.get(opcode);
        String icLine = "(IS, " + info[1] + ") ";

        if (op1 != null) {
            if (REGTAB.containsKey(op1)) icLine += "(" + REGTAB.get(op1) + ") ";
            else if (CONDTAB.containsKey(op1)) icLine += "(" + CONDTAB.get(op1) + ") ";
        }

        if (op2 != null) {
            if (op2.startsWith("=")) addLiteral(op2);
            else {
                if (!SYMTAB.containsKey(op2)) SYMTAB.put(op2, -1);
                icLine += "(S," + (findSymbolIndex(op2) + 1) + ")";
            }
        }

        IC.add(icLine.trim());
    }

    // Handle Literal Pool at LTORG or END
    static void handleLiteralPool() {
        int poolStart = POOLTAB.get(POOLTAB.size() - 1);
        boolean added = false;

        for (int i = poolStart; i < LITTAB.size(); i++) {
            Literal lit = LITTAB.get(i);
            if (lit.address == -1) {
                lit.address = LC++;
                String val = lit.value.replace("='", "").replace("'", "");
                IC.add("(DL, 01) (C, " + val + ")");
                added = true;
            }
        }

        if (added && POOLTAB.get(POOLTAB.size() - 1) != LITTAB.size())
            POOLTAB.add(LITTAB.size());
    }

    // Add Literal to Pool (no duplicates in current pool)
    static void addLiteral(String lit) {
        int poolStart = POOLTAB.get(POOLTAB.size() - 1);
        for (int i = poolStart; i < LITTAB.size(); i++)
            if (LITTAB.get(i).value.equals(lit)) return; // already exists
        LITTAB.add(new Literal(lit));
    }

    // Evaluate expressions like A+2 or A-1
    static int evaluateExpression(String expr) {
        if (expr.contains("+") || expr.contains("-")) {
            String[] parts = expr.split("(?=[+-])");
            String baseSym = parts[0];
            int base = SYMTAB.getOrDefault(baseSym, -1);
            if (base == -1) throw new RuntimeException("Undefined symbol: " + baseSym);
            return base + Integer.parseInt(parts[1]);
        }
        if (SYMTAB.containsKey(expr)) return SYMTAB.get(expr);
        return Integer.parseInt(expr);
    }

    // ---------- Utility Tables ----------

    static boolean isDirective(String s) {
        return List.of("START", "END", "ORIGIN", "EQU", "LTORG", "DS", "DC").contains(s);
    }

    static void initTables() {
        OPTAB.put("STOP", new String[]{"IS", "00"});
        OPTAB.put("ADD", new String[]{"IS", "01"});
        OPTAB.put("SUB", new String[]{"IS", "02"});
        OPTAB.put("MULT", new String[]{"IS", "03"});
        OPTAB.put("MOVER", new String[]{"IS", "04"});
        OPTAB.put("MOVEM", new String[]{"IS", "05"});
        OPTAB.put("COMP", new String[]{"IS", "06"});
        OPTAB.put("BC", new String[]{"IS", "07"});
        OPTAB.put("DIV", new String[]{"IS", "08"});
        OPTAB.put("READ", new String[]{"IS", "09"});
        OPTAB.put("PRINT", new String[]{"IS", "10"});

        REGTAB.put("AREG", 1);
        REGTAB.put("BREG", 2);
        REGTAB.put("CREG", 3);
        REGTAB.put("DREG", 4);

        CONDTAB.put("LT", 1);
        CONDTAB.put("LE", 2);
        CONDTAB.put("EQ", 3);
        CONDTAB.put("GT", 4);
        CONDTAB.put("GE", 5);
        CONDTAB.put("ANY", 6);
    }

    // Find symbol index (for IC representation)
    static int findSymbolIndex(String sym) {
        int i = 0;
        for (String s : SYMTAB.keySet()) {
            if (s.equals(sym)) return i;
            i++;
        }
        return -1;
    }

    // ---------- Output Section ----------
    static void printAndWriteOutputs() throws IOException {
        System.out.println("Intermediate Code:");
        IC.forEach(System.out::println);

        System.out.println("\\nSymbol Table:");
        SYMTAB.forEach((k, v) -> System.out.println(k + " = " + v));

        System.out.println("\\nLiteral Table:");
        int i = 1;
        for (Literal l : LITTAB) System.out.println((i++) + ") " + l.value + " = " + l.address);

        System.out.println("\\nPool Table:");
        for (int j = 0; j < POOLTAB.size(); j++) {
            int p = POOLTAB.get(j);
            if (p < LITTAB.size())
                System.out.println("#" + (j + 1) + " starts at literal #" + (p + 1));
            else
                System.out.println("#" + (j + 1) + " starts at literal #<none>");
        }

        writeFile("intermediate.txt", IC);
        writeFile("symtab.txt", SYMTAB);
        writeFile("littab.txt", LITTAB);
    }

    static void writeFile(String filename, Object data) throws IOException {
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(filename))) {
            if (data instanceof List<?>) {
                for (Object line : (List<?>) data)
                    writer.write(line.toString() + "\\n");
            } else if (data instanceof Map<?, ?>) {
                for (Map.Entry<?, ?> e : ((Map<?, ?>) data).entrySet())
                    writer.write(e.getKey() + " = " + e.getValue() + "\\n");
            } else if (data instanceof List<?>) {
                for (Object l : (List<?>) data)
                    writer.write(l.toString() + "\\n");
            } else if (data instanceof List<?>) {
                for (Literal l : (List<Literal>) data)
                    writer.write(l.value + " = " + l.address + "\\n");
            }
        }
    }
}
        </pre>
      </div>
    </div>

  </div>

<script>
/* ---------- Data structure (extracted from your React algorithm) ---------- */
const algorithm = [
  {
    phase: "INITIALIZATION PHASE",
    steps: [
      {
        title: "Step 1: Initialize Data Structures",
        description: "Create empty tables to store information during assembly",
        details: [
          "Create OPTAB (Operation Table) - Store all machine instructions",
          "Create SYMTAB (Symbol Table) - Will store labels and their addresses",
          "Create LITTAB (Literal Table) - Will store literals like ='5'",
          "Create POOLTAB (Pool Table) - Track literal pool starting points",
          "Create REGTAB (Register Table) - Store register codes",
          "Create CONDTAB (Condition Table) - Store condition codes",
          "Create IC list (Intermediate Code) - Store generated code lines",
          "Set Location Counter LC = 0"
        ],
        code: `OPTAB = {"MOVER": "04", "ADD": "01", ...}
SYMTAB = {}  // Empty initially
LITTAB = []  // Empty initially
POOLTAB = [0]  // First pool starts at index 0
REGTAB = {"AREG": 1, "BREG": 2, ...}
CONDTAB = {"LT": 1, "EQ": 3, ...}
IC = []  // Empty initially
LC = 0`,
        example: "All tables are ready to use!"
      },
      {
        title: "Step 2: Open Source File",
        description: "Read the assembly language source code file",
        details: [
          "Open file 'program2.asm' for reading",
          "Prepare to read line by line",
          "Initialize first pool in POOLTAB with index 0"
        ],
        code: `BufferedReader reader = new BufferedReader(
    new FileReader("program2.asm")
);
POOLTAB.add(0);  // Mark first pool`,
        example: "File: START 200\\nLOOP MOVER AREG, ='5'\\n..."
      }
    ]
  },
  {
    phase: "MAIN PROCESSING LOOP",
    steps: [
      {
        title: "Step 3: Read Next Line",
        description: "Get one line from the source file",
        details: [
          "Read one line from the assembly file",
          "Remove leading/trailing whitespace",
          "Skip if line is empty",
          "Continue until end of file"
        ],
        code: `while ((line = readLine()) != null) {
    line = line.trim();
    if (line.isEmpty()) continue;
    // Process this line...
}`,
        example: "Line read: 'LOOP MOVER AREG, ='5''"
      },
      {
        title: "Step 4: Parse Line into Tokens",
        description: "Break the line into individual parts (tokens)",
        details: [
          "Split line by spaces and commas",
          "Remove empty tokens",
          "Store tokens in array for processing"
        ],
        code: `tokens = line.split by spaces and commas
Remove empty strings
Result: [token1, token2, token3, ...]`,
        example: "Input: 'LOOP MOVER AREG, ='5''\\nTokens: ['LOOP', 'MOVER', 'AREG', '='5'']"
      },
      {
        title: "Step 5: Identify Line Components",
        description: "Determine if line has label, and extract opcode and operands",
        details: [
          "Check first token:",
          "  - If it's an instruction/directive ‚Üí No label, first token is opcode",
          "  - If it's NOT an instruction ‚Üí First token is label, second is opcode",
          "Extract operand1 (if exists)",
          "Extract operand2 (if exists)"
        ],
        code: `if (first_token is instruction/directive):
    label = null
    opcode = token[0]
    operand1 = token[1] (if exists)
    operand2 = token[2] (if exists)
else:
    label = token[0]
    opcode = token[1]
    operand1 = token[2] (if exists)
    operand2 = token[3] (if exists)`,
        example: "'LOOP MOVER AREG, ='5''\\nlabel='LOOP', opcode='MOVER', op1='AREG', op2='='5''"
      },
      {
        title: "Step 6: Process Label (if exists)",
        description: "If line has a label, add it to Symbol Table",
        details: [
          "If label exists:",
          "  - Add label to SYMTAB",
          "  - Store current LC as its address",
          "  - Format: SYMTAB[label] = LC"
        ],
        code: `if (label != null) {
    SYMTAB[label] = LC;
}`,
        example: "LOOP found ‚Üí SYMTAB['LOOP'] = 200"
      },
      {
        title: "Step 7: Check Instruction Type",
        description: "Determine if it's a directive or machine instruction",
        details: [
          "Check if opcode is a directive:",
          "  - START, END, ORIGIN, EQU, LTORG, DS, DC",
          "If YES ‚Üí Go to Step 8 (Process Directive)",
          "If NO ‚Üí Go to Step 9 (Process Machine Instruction)"
        ],
        code: `if (opcode in [START, END, ORIGIN, EQU, LTORG, DS, DC]):
    processDirective()
else:
    processMachineInstruction()`,
        example: "MOVER is NOT a directive ‚Üí Process as machine instruction"
      }
    ]
  },
  {
    phase: "DIRECTIVE PROCESSING",
    steps: [
      {
        title: "Step 8A: Process START Directive",
        description: "Set the starting address of the program",
        details: [
          "Extract starting address from operand1",
          "Set LC = starting address",
          "Generate IC: (AD,01) (C,address)",
          "Do NOT increment LC"
        ],
        code: `START operand1:
    LC = parseInt(operand1)
    IC.add("(AD,01) (C," + operand1 + ")")
    // LC not incremented`,
        example: "START 200 ‚Üí LC=200, IC='(AD,01) (C,200)'"
      },
      {
        title: "Step 8B: Process END Directive",
        description: "Mark end of program and assign all pending literals",
        details: [
          "Call assignLiteralAddresses() to process all literals",
          "Generate IC: (AD,02)",
          "Do NOT increment LC",
          "This is usually the last line"
        ],
        code: `END:
    assignLiteralAddresses()  // Assign all literals
    IC.add("(AD,02)")
    // LC not incremented`,
        example: "END ‚Üí All literals get addresses, IC='(AD,02)'"
      },
      {
        title: "Step 8C: Process LTORG Directive",
        description: "Create a literal pool and assign addresses to literals",
        details: [
          "Call assignLiteralAddresses() to process current pool",
          "Generate IC: (AD,05)",
          "Do NOT increment LC separately (done by assignLiteralAddresses)"
        ],
        code: `LTORG:
    assignLiteralAddresses()  // Create pool
    IC.add("(AD,05)")`,
        example: "LTORG ‚Üí ='5' gets address 203"
      },
      {
        title: "Step 8D: Process ORIGIN Directive",
        description: "Change the Location Counter to a new address",
        details: [
          "Evaluate expression (could be 'LOOP+1' or just '300')",
          "Set LC = evaluated value",
          "Generate IC: (AD,03) (C,value)",
          "LC is now at new location"
        ],
        code: `ORIGIN expression:
    new_value = evaluateExpression(operand1)
    LC = new_value
    IC.add("(AD,03) (C," + new_value + ")")`,
        example: "ORIGIN LOOP+2 ‚Üí If LOOP=200, then LC=202"
      },
      {
        title: "Step 8E: Process EQU Directive",
        description: "Define a symbol with a calculated value",
        details: [
          "Evaluate expression to get value",
          "Update symbol's value in SYMTAB (symbol is the label)",
          "Do NOT generate IC",
          "Do NOT increment LC"
        ],
        code: `label EQU expression:
    value = evaluateExpression(operand1)
    SYMTAB[label] = value
    // No IC generated
    // LC not changed`,
        example: "MAX EQU LOOP+5 ‚Üí SYMTAB['MAX'] = 205"
      },
      {
        title: "Step 8F: Process DS Directive",
        description: "Reserve space for data (Define Storage)",
        details: [
          "Extract size from operand1",
          "Generate IC: (DL,02) (C,size)",
          "Increment LC by size",
          "This reserves memory without storing value"
        ],
        code: `DS size:
    IC.add("(DL,02) (C," + operand1 + ")")
    LC = LC + parseInt(operand1)`,
        example: "A DS 1 ‚Üí Reserve 1 word, LC increases by 1"
      },
      {
        title: "Step 8G: Process DC Directive",
        description: "Define a constant value (Define Constant)",
        details: [
          "Extract constant value from operand1",
          "Remove quotes from value",
          "Generate IC: (DL,01) (C,value)",
          "Increment LC by 1"
        ],
        code: `DC 'value':
    constant = operand1.remove quotes
    IC.add("(DL,01) (C," + constant + ")")
    LC = LC + 1`,
        example: "X DC '5' ‚Üí Store 5 at current LC, LC++"
      }
    ]
  },
  {
    phase: "MACHINE INSTRUCTION PROCESSING",
    steps: [
      {
        title: "Step 9: Start Processing Machine Instruction",
        description: "Begin generating intermediate code for instruction",
        details: [
          "Look up opcode in OPTAB to get machine code",
          "Start building IC line with (IS,code)",
          "Prepare to process operands"
        ],
        code: `opcode_num = OPTAB[opcode]
IC_line = "(IS," + opcode_num + ")"`,
        example: "MOVER ‚Üí OPTAB['MOVER']='04' ‚Üí IC='(IS,04)'"
      },
      {
        title: "Step 10: Process First Operand",
        description: "Handle the first operand (usually register or condition)",
        details: [
          "If operand1 exists:",
          "  - Check if it's a register (in REGTAB)",
          "    ‚Üí Add (register_code) to IC",
          "  - Check if it's a condition (in CONDTAB)",
          "    ‚Üí Add (condition_code) to IC",
          "  - If neither, skip (will be handled as symbol)"
        ],
        code: `if operand1 in REGTAB:
    reg_code = REGTAB[operand1]
    IC_line += " (" + reg_code + ")"
else if operand1 in CONDTAB:
    cond_code = CONDTAB[operand1]
    IC_line += " (" + cond_code + ")"`,
        example: "AREG ‚Üí REGTAB['AREG']=1 ‚Üí IC='(IS,04) (1)'"
      },
      {
        title: "Step 11A: Process Second Operand - Literal",
        description: "If second operand is a literal (starts with =)",
        details: [
          "Check if literal already exists in current pool",
          "If NOT in current pool:",
          "  - Add literal to LITTAB",
          "  - Address remains -1 (assigned later by LTORG/END)",
          "Find literal's index in LITTAB",
          "Add (L,index) to IC line"
        ],
        code: `if operand2 starts with '=':
    if literal not in current pool:
        LITTAB.add(new Literal(operand2))
    lit_index = findLiteralIndex(operand2) + 1
    IC_line += " (L," + lit_index + ")"`,
        example: "='5' ‚Üí Add to LITTAB, IC='(IS,04) (1) (L,1)'"
      },
      {
        title: "Step 11B: Process Second Operand - Symbol",
        description: "If second operand is a symbol (variable/label)",
        details: [
          "Check if symbol exists in SYMTAB",
          "If NOT exists:",
          "  - Add symbol to SYMTAB with value=-1 (forward reference)",
          "  - Will be updated when symbol is defined",
          "Find symbol's index in SYMTAB",
          "Add (S,index) to IC line"
        ],
        code: `if operand2 not starts with '=':
    if operand2 not in SYMTAB:
        SYMTAB[operand2] = -1  // Forward reference
    sym_index = getSymbolIndex(operand2) + 1
    IC_line += " (S," + sym_index + ")"`,
        example: "A ‚Üí Not defined yet, SYMTAB['A']=-1, IC='(IS,01) (1) (S,2)'"
      },
      {
        title: "Step 12: Complete Machine Instruction",
        description: "Finalize the intermediate code and increment LC",
        details: [
          "Add complete IC line to IC list",
          "Increment LC by 1 (each instruction takes 1 word)",
          "Return to Step 3 to read next line"
        ],
        code: `IC.add(IC_line)
LC = LC + 1
goto Step 3  // Read next line`,
        example: "Final IC: '(IS,04) (1) (L,1)', LC=201"
      }
    ]
  },
  {
    phase: "LITERAL ASSIGNMENT SUBROUTINE",
    steps: [
      {
        title: "Step 13: Assign Literal Addresses (Called by LTORG/END)",
        description: "Give memory addresses to all unassigned literals in current pool",
        details: [
          "Get starting point of current pool from POOLTAB",
          "For each literal from pool start to end of LITTAB:",
          "  - If literal address is -1 (unassigned):",
          "    ‚Üí Set literal.address = current LC",
          "    ‚Üí Extract value from literal (remove =' and ')",
          "    ‚Üí Generate IC: (DL,01) (C,value)",
          "    ‚Üí Increment LC by 1",
          "After all literals assigned:",
          "  - Add new pool marker to POOLTAB = current LITTAB size"
        ],
        code: `poolStart = POOLTAB[last]
for i from poolStart to LITTAB.size:
    if LITTAB[i].address == -1:
        LITTAB[i].address = LC
        value = extract from LITTAB[i].value
        IC.add("(DL,01) (C," + value + ")")
        LC = LC + 1
POOLTAB.add(LITTAB.size)  // New pool starts here`,
        example: "='5' at LC=203 ‚Üí LITTAB[0].address=203, IC='(DL,01) (C,5)', LC=204"
      }
    ]
  },
  {
    phase: "COMPLETION PHASE",
    steps: [
      {
        title: "Step 14: Display Results",
        description: "Print all generated tables and intermediate code",
        details: [
          "Print INTERMEDIATE CODE",
          "Print SYMBOL TABLE (all symbols and addresses)",
          "Print LITERAL TABLE (all literals and addresses)",
          "Print POOL TABLE (pool starting points)"
        ],
        code: `print "=== INTERMEDIATE CODE ==="
for each line in IC: print line

print "=== SYMBOL TABLE ==="
for each entry in SYMTAB: print symbol = address

print "=== LITERAL TABLE ==="
for each literal in LITTAB: print literal = address

print "=== POOL TABLE ==="
for each pool in POOLTAB: print pool number and start`,
        example: "All tables displayed on console"
      },
      {
        title: "Step 15: Write Output Files",
        description: "Save all generated information to files",
        details: [
          "Write intermediate.txt:",
          "  - Each IC line on new line",
          "Write symtab.txt:",
          "  - Each symbol and address (symbol = address)",
          "Write littab.txt:",
          "  - Each literal and address (literal = address)",
          "Close all files"
        ],
        code: `Write to "intermediate.txt":
    Each line from IC

Write to "symtab.txt":
    Each entry: symbol = address

Write to "littab.txt":
    Each entry: literal = address

Close all files`,
        example: "3 files created successfully!"
      },
      {
        title: "Step 16: End Program",
        description: "Pass One is complete!",
        details: [
          "All tables are built",
          "Intermediate code is generated",
          "Output files are saved",
          "Pass Two can now use these files to generate machine code"
        ],
        code: `print "‚úì Pass One Complete!"
exit(0)`,
        example: "Ready for Pass Two!"
      }
    ]
  }
];

/* ---------- Render UI ---------- */
const root = document.getElementById('phases-root');

function createPhaseElement(phaseObj, pIndex) {
  const phase = document.createElement('div'); phase.className='phase';
  const header = document.createElement('div'); header.className='phase-header';
  const icon = document.createElement('div'); icon.style.width='36px'; icon.style.height='36px';
  icon.style.display='grid';icon.style.placeItems='center';icon.style.borderRadius='8px';
  icon.style.background='rgba(255,255,255,0.06)'; icon.style.color='white'; icon.style.fontWeight='700';
  icon.textContent='‚ñ∂';
  const h2 = document.createElement('h2'); h2.textContent = phaseObj.phase;
  header.appendChild(icon); header.appendChild(h2);
  phase.appendChild(header);

  const body = document.createElement('div'); body.className='phase-body';

  phaseObj.steps.forEach((stepObj, sIndex) => {
    const stepWrap = document.createElement('div'); stepWrap.className='step';
    const btn = document.createElement('button'); btn.className='step-button';
    btn.type='button';

    const iconDot = document.createElement('div'); iconDot.className='icon'; iconDot.textContent = String(sIndex+1);
    const content = document.createElement('div'); content.className='step-content';
    const t = document.createElement('h3'); t.className='step-title'; t.textContent = stepObj.title;
    const d = document.createElement('p'); d.className='step-desc'; d.textContent = stepObj.description;

    const chev = document.createElement('div'); chev.className='chev'; chev.innerHTML='‚Ä∫';

    content.appendChild(t); content.appendChild(d);
    btn.appendChild(iconDot); btn.appendChild(content); btn.appendChild(chev);
    stepWrap.appendChild(btn);

    // details area (hidden by default)
    const details = document.createElement('div'); details.className='details'; details.style.display='none';
    // detailed steps
    const detBlock = document.createElement('div'); detBlock.className='block';
    const detTitle = document.createElement('h4'); detTitle.textContent='üìã Detailed Steps:';
    detBlock.appendChild(detTitle);
    const ul = document.createElement('ul'); ul.className='list';
    stepObj.details.forEach(it=>{
      const li = document.createElement('li'); li.textContent = it;
      ul.appendChild(li);
    });
    detBlock.appendChild(ul);
    details.appendChild(detBlock);

    // pseudocode block
    const codeBlock = document.createElement('div'); codeBlock.className='block';
    const codeTitle = document.createElement('h4'); codeTitle.textContent='üíª Pseudocode:';
    const pre = document.createElement('pre'); pre.className='code';
    pre.textContent = stepObj.code;
    codeBlock.appendChild(codeTitle); codeBlock.appendChild(pre);
    details.appendChild(codeBlock);

    // example block
    const exBlock = document.createElement('div'); exBlock.className='block';
    const exTitle = document.createElement('h4'); exTitle.textContent='‚ú® Example:';
    const ex = document.createElement('div'); ex.className='example'; ex.textContent = stepObj.example;
    exBlock.appendChild(exTitle); exBlock.appendChild(ex);
    details.appendChild(exBlock);

    // Add small connector except last step
    btn.addEventListener('click', ()=>{
      const allButtons = document.querySelectorAll('.step-button');
      allButtons.forEach(b=>b.classList.remove('current'));
      const allChevs = document.querySelectorAll('.chev'); allChevs.forEach(c=>c.classList.remove('rotate'));
      btn.classList.add('current');
      chev.classList.add('rotate');
      // mark completed when clicked (toggle)
      if (!btn.classList.contains('completed')) {
        btn.classList.add('completed');
        iconDot.classList.add('completed');
      }
      // toggle details display
      const visible = details.style.display === 'block';
      // hide all details
      document.querySelectorAll('.details').forEach(el=>el.style.display='none');
      if (!visible) details.style.display = 'block';
      else details.style.display = 'none';
      // scroll small amount into view for mobile
      setTimeout(()=>{ details.scrollIntoView({behavior:'smooth', block:'center'}); }, 120);
    });

    stepWrap.appendChild(details);

    // connector line if not last in phase
    if (sIndex < phaseObj.steps.length - 1) {
      const conn = document.createElement('div'); conn.className='connector';
      const line = document.createElement('div'); line.className='line'; conn.appendChild(line);
      stepWrap.appendChild(conn);
    }

    body.appendChild(stepWrap);
  });

  phase.appendChild(body);

  // connector between phases
  if (pIndex < algorithm.length - 1) {
    const outer = document.createElement('div'); outer.style.display='flex';outer.style.justifyContent='center';outer.style.margin='14px 0';
    const col = document.createElement('div'); col.style.display='flex';col.style.flexDirection='column';col.style.alignItems='center';
    const line = document.createElement('div'); line.style.width='2px';line.style.height='44px';line.style.background='#c7d2fe';line.style.borderRadius='2px';
    const arrow = document.createElement('div'); arrow.style.transform='rotate(90deg)'; arrow.style.marginTop='8px'; arrow.style.color='#4338ca';
    arrow.innerHTML='&#8250;'; col.appendChild(line); col.appendChild(arrow); outer.appendChild(col);
    phase.appendChild(outer);
  }

  return phase;
}

(function init() {
  algorithm.forEach((ph, idx)=>{
    const el = createPhaseElement(ph, idx);
    root.appendChild(el);
  });
})();

/* ---------- Copy & Toggle Java code ---------- */
const copyBtn = document.getElementById('copyBtn');
const toggleBtn = document.getElementById('toggleBtn');
const javaBlock = document.getElementById('javaBlock');
const javaCode = document.getElementById('javaCode').innerText;

copyBtn.addEventListener('click', async ()=>{
  try {
    await navigator.clipboard.writeText(javaCode);
    copyBtn.textContent = 'Copied ‚úì';
    setTimeout(()=> copyBtn.textContent = 'Copy code', 1600);
  } catch (e) {
    copyBtn.textContent = 'Copy failed';
    setTimeout(()=> copyBtn.textContent = 'Copy code', 1600);
  }
});

toggleBtn.addEventListener('click', ()=>{
  if (javaBlock.style.display === 'none') {
    javaBlock.style.display = 'block'; toggleBtn.textContent = 'Hide';
  } else {
    javaBlock.style.display = 'none'; toggleBtn.textContent = 'Show';
  }
});
</script>
</body>
</html>
